<%!func DaoTemplate(w io.Writer, daoData DaoTemplateData) error %>package  <%= daoData.DaoPkgName %>

// NOTE: THIS FILE WAS PRODUCED BY THE
// GOMA CODE GENERATION TOOL (github.com/kyokomi/goma)
// DO NOT EDIT

import (
    "log"
    
    "database/sql"
    
    "<%= daoData.EntityImport %>"
    
    "github.com/kyokomi/goma"
)

// <%= daoData.Name %> is generated <%= daoData.Table.Name %> table.
type <%= daoData.Name %> struct {
	*goma.Goma
	tx *sql.Tx
	TableName string
}

// <%= daoData.Table.TitleName %> is <%= daoData.Name %>.
func <%= daoData.Table.TitleName %>(g *goma.Goma) <%= daoData.Name %> {
    tblDao := <%= daoData.Name %>{}
    tblDao.Goma = g
    tblDao.tx = nil
    tblDao.TableName = "<%= daoData.Table.TitleName %>"
	return tblDao
}

// IsTx started transaction?
func (d <%= daoData.Name %>) IsTx() bool {
	return d.tx != nil
}

// SetTx set transaction.
func (d *<%= daoData.Name %>) SetTx(tx *sql.Tx) {
	d.tx = tx
}

// ResetTx reset transaction.
// Call after Commit of Rollback.
func (d *<%= daoData.Name %>) ResetTx() {
	d.tx = nil
}

func (d <%= daoData.Name %>) daoQuery(query string, args ...interface{}) (rows *sql.Rows, err error) {
	if d.IsTx() {
		rows, err = d.tx.Query(query, args...)
	} else {
		rows, err = d.Query(query, args...)
	}
	return
}

func (d <%= daoData.Name %>) daoExec(query string, args ...interface{}) (result sql.Result, err error) {
	if d.IsTx() {
		result, err = d.tx.Exec(query, args...)
	} else {
		result, err = d.Exec(query, args...)
	}
	return
}

// SelectAll select <%= daoData.Table.Name %> table all recode.
func (d <%= daoData.Name %>) SelectAll() ([]*<%= daoData.EntityPkgName %>.<%= daoData.EntityName %>, error) {
    queryString := d.QueryArgs("<%= daoData.Table.Name %>", "selectAll", nil)

	var entitys []*<%= daoData.EntityPkgName %>.<%= daoData.EntityName %>
	rows, err := d.daoQuery(queryString)
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var entity <%= daoData.EntityPkgName %>.<%= daoData.EntityName %>
		err = rows.Scan(<% for idx, column := range daoData.Table.Columns { %><% if idx != 0 { %>, <% } %>&entity.<%= column.TitleName %><% } %>)
		if err != nil {
			break
		}

		entitys = append(entitys, &entity)
	}
	if err != nil {
	    log.Println(err, queryString)
		return nil, err
	}

	return entitys, nil
}

// SelectByID select <%= daoData.Table.Name %> table by primaryKey.
func (d <%= daoData.Name %>) SelectByID(<% for idx, column := range daoData.Table.Columns { %><% if !column.IsPrimaryKey { %><% continue %><% } %><% if idx != 0 { %>, <% } %><%= column.Name %> <%= column.TypeName %><% } %>) (*<%= daoData.EntityPkgName %>.<%= daoData.EntityName %>, error) {
    args := goma.QueryArgs{
    <% for _, column := range daoData.Table.Columns { %><% if !column.IsPrimaryKey { %><% continue %><% } %>    "<%= column.Name %>": <%= column.Name %>,
    <% } %>}
	queryString := d.QueryArgs("<%= daoData.Table.Name %>", "selectByID", args)

	rows, err := d.daoQuery(queryString)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	if !rows.Next() {
		return nil, nil
	}

	var entity <%= daoData.EntityPkgName %>.<%= daoData.EntityName %>
	if err := rows.Scan(<% for idx, column := range daoData.Table.Columns { %><% if idx != 0 { %>, <% } %>&entity.<%= column.TitleName %><% } %>); err != nil {
	    log.Println(err, queryString)
		return nil, err
	}
	
	return &entity, nil
}

// Insert insert <%= daoData.Table.Name %> table.
func (d <%= daoData.Name %>) Insert(entity <%= daoData.EntityPkgName %>.<%= daoData.EntityName %>) (sql.Result, error) {
	args := goma.QueryArgs{
    <% for _, column := range daoData.Table.Columns { %>  "<%= column.Name %>": entity.<%= column.TitleName %>,
    <% } %>
	}
	queryString := d.QueryArgs("<%= daoData.Table.Name %>", "insert", args)
	
	result, err := d.daoExec(queryString)
    if err != nil {
        log.Println(err, queryString)
    }
    return result, err
}

// Update update <%= daoData.Table.Name %> table.
func (d <%= daoData.Name %>) Update(entity <%= daoData.EntityPkgName %>.<%= daoData.EntityName %>) (sql.Result, error) {
	args := goma.QueryArgs{
	<% for _, column := range daoData.Table.Columns { %>  "<%= column.Name %>": entity.<%= column.TitleName %>,
    <% } %>
	}
	queryString := d.QueryArgs("<%= daoData.Table.Name %>", "update", args)

	result, err := d.daoExec(queryString)
	if err != nil {
        log.Println(err, queryString)
    }
    return result, err
}

// Delete delete <%= daoData.Table.Name %> table by primaryKey.
func (d <%= daoData.Name %>) Delete(<% for idx, column := range daoData.Table.Columns { %><% if !column.IsPrimaryKey { %><% continue %><% } %><% if idx != 0 { %>, <% } %><%= column.Name %> <%= column.TypeName %><% } %>) (sql.Result, error) {
    args := goma.QueryArgs{
    <% for _, column := range daoData.Table.Columns { %><% if !column.IsPrimaryKey { %><% continue %><% } %>    "<%= column.Name %>": <%= column.Name %>,
    <% } %>}
	queryString := d.QueryArgs("<%= daoData.Table.Name %>", "delete", args)

    result, err := d.daoExec(queryString)
	if err != nil {
        log.Println(err, queryString)
    }
    return result, err
}
